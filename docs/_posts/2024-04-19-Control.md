---
title: "Control"
last_modified_at: 2024-05-06T10:30:00
categories:
  - Blog
tags:
  - PID
  - Redes neuronales
---

Implementaremos una solución combinando múltiples redes neuronales para detectar el carril y calcular la desviación del vehículo respecto al mismo. Esta información se enviará a un controlador PID para corregir la desviación y mantener al vehículo en adecuadamente en el centro del carril.

## Detección de carril

Buscamos seleccionar un entorno con una única vía, rodeado de vegetación y con un cielo despejado, con el objetivo de minimizar la confusión entre el cielo, la carretera y los edificios.

### Red neuronal de segmentación semántica

Filtramos la salida de la red de segmentación para aislar el área correspondiente a la calzada y calculamos el centro de masas de la calzada. Determinamos la desviación del carril como la diferencia en el eje *x* entre el centro de masas y el centro de la imagen, que se alinea con el centro del vehículo.
<figure class="align-center" style="max-width: 100%">
  <img src="{{ site.url }}{{ site.baseurl }}/images/control/seg.png" alt="">
</figure>

### Red neuronal de detección de carril

Esta red neuronal está diseñada para detectar tanto las líneas derecha como izquierda del carril, para activar su funcionamiento, hemos añadido una nueva *flag* a la cámara llamada *lane*. Tambien hemos añadido funciones obtener la desviacion del carril en pixles, que usaremos en el controlador, y para consultar o modificar el valor del umbral o del offset. Con el objetivo de mejorar la eficiencia, ejecutaremos esta red en un hilo separado, mientras que la red de segmentación se ejecuta en el hilo principal.
```python
def add_camera_rgb(self, size_rect:tuple[int, int]=None, init:tuple[int, int]=None, seg:bool=False,
                   transform:carla.Transform=carla.Transform(), init_extra:tuple[int, int]=None,
                   text:str=None, lane:bool=False):

class CameraRGB(Sensor):  
  def get_deviation(self)
  
  def get_threshold_lane(self)
  def set_threshold_lane(self, threshold:float):

  def get_offset_lane(self)
  def set_offset_lane(self, offset:int)
```

La entrada de la red neuronal es una imagen de 1024x512 píxeles. Para preparar esta imagen antes de enviarla a la red, colocamos la imagen capturada por la cámara en la esquina superior izquierda de una imagen completamente negra. Una vez que la red ha procesado la imagen, obtenemos dos máscaras: una para el carril izquierdo y otra para el derecho, ambas del tamaño 1024x512 píxeles. Nos interesan únicamente las primeras 512 columnas de estas máscaras, los píxeles que esten por encima de cierto umbral son los que peretenecn a la slienas del carril.

A la hora de calcular el centro de masas, solo consideraremos los píxeles dentro de los límites del carril, para ello, identificamos el píxel más a la derecha y a la izquierda de cada fila correspondiente y posteriormente los conectamos. Este proceso  se guarda un *array* de 512 filas y 2 columnas, inicialmente con valor -1.
<figure class="align-center" style="max-width: 100%">
  <img src="{{ site.url }}{{ site.baseurl }}/images/control/lane.png" alt="">
</figure>

Para rellenar los huecos, intentaremos simular la calzada. Creamos una variable que almacena los límites de la fila anterior de la calzada, inicialmente ambos son el centro del eje x. En cada actualización, los limites no definidos (con valor -1) se establcen como el valor de la fila anterior más un *offset*, que en este caso es 1. Comprobamos que dicho valor no supere el maximo registrado con la red de deteccion de carril. 

Estos dos procesos **solo son validos si se confirma con la mascra de segmentacion** que todo ese rango de la fila pertenece a al calzada.

La parte en rosa representa la sección definida únicamente con la red de detección de carriles, mientras que la sección en verde muestra la parte completada con la red de segmentación.
<figure class="align-center" style="max-width: 100%">
  <img src="{{ site.url }}{{ site.baseurl }}/images/control/lane_seg.png" alt="">
</figure>

## Controlador PID

Para que el vehiculo siga al carril hemosm creado finalmenet un **controlador proporcional**, ya que solo con elloobstenimos buenos resultados. El *steer*, giro de volante, puede recibir un valor de 0 a 1, por lo tanto, la contante proporcional normalizara el error en este rango, dividiendo entre la mitad de la imagen 512/2. 

Para controlar el acelerador, si el error es mayor que 15 pixeles disminuimos el acelerador, de lo contrario mantenemos una aceleracion estandar. Hemos establecido un contador para que al principio acelera mas, para alcanzar antes una velocidad adecuada.