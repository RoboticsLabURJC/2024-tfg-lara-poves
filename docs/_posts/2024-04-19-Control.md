---
title: "Control"
last_modified_at: 2024-05-06T13:34:00
categories:
  - Blog
tags:
  - PID
  - Redes neuronales
---

Implementaremos una solución combinando múltiples redes neuronales para detectar el carril y calcular la desviación del vehículo respecto al mismo. Esta información se enviará a un controlador PID para corregir la desviación y mantener al vehículo en adecuadamente en el centro del carril.

## Índice
1. [Detección de carril](#detección-de-carril)
    - [Red neuronal de segmentación semántica](#red-neuronal-de-segmentación-semántica)
    - [Red neuronal de detección de carril](#red-neuronal-de-detección-de-carril)
2. [Controlador PID](#controlador-pid)

## Detección de carril

Buscamos seleccionar un entorno con una única vía, rodeado de vegetación y con un cielo despejado, con el objetivo de minimizar la confusión entre el cielo, la carretera y los edificios.

### Red neuronal de segmentación semántica

Filtramos la salida de la red de segmentación para aislar el área correspondiente a la calzada y calculamos el centro de masas de la calzada. Determinamos la desviación del carril como la diferencia en el eje *x* entre el centro de masas y el centro de la imagen, que se alinea con el centro del vehículo.
<figure class="align-center" style="max-width: 100%">
  <img src="{{ site.url }}{{ site.baseurl }}/images/control/seg.png" alt="">
</figure>

### Red neuronal de detección de carril

Esta red neuronal está diseñada para detectar las líneas del carril, para activar su funcionamiento, hemos añadido una nueva *flag* a la cámara denominada *lane*. Además, hemos implementado funciones para obtener la desviación del vehículo respecto al carril en píxeles, la cual sera utilizada en el controlador, así como para consultar o modificar el valor del umbral y del *offset*. Con el objetivo de mejorar la eficiencia, ejecutaremos esta red en un hilo separado, mientras que la red de segmentación se ejecuta en el hilo principal.
```python
def add_camera_rgb(self, size_rect:tuple[int, int]=None, init:tuple[int, int]=None, seg:bool=False,
                   transform:carla.Transform=carla.Transform(), init_extra:tuple[int, int]=None,
                   text:str=None, lane:bool=False):

class CameraRGB(Sensor):  
  def get_deviation(self)
  
  def get_threshold_lane(self)
  def set_threshold_lane(self, threshold:float)

  def get_offset_lane(self)
  def set_offset_lane(self, offset:int)
```

La entrada de la red neuronal es una imagen de 1024x512 píxeles, por lo tanto, antes de enviar una imagen a la red debemos adaptar sus dimensiones, la colocamos en la esquina superior izquierda de una imagen completamente negra. Una vez que la red ha procesado la imagen obtenemos dos máscaras: una para el carril izquierdo y otra para el derecho, ambas del tamaño 1024x512 píxeles. Nos interesan únicamente las primeras 512 columnas de estas máscaras, los píxeles que estén por encima de cierto umbral son los que pertenecen a la líneas del carril.

A la hora de calcular el centro de masas, solo consideraremos los píxeles dentro de los límites del carril, para ello, identificamos el píxel más a la derecha y a la izquierda de cada fila correspondiente y posteriormente los conectamos. Este proceso  se guarda un *array* de 512 filas y 2 columnas, inicialmente con valor -1.
<figure class="align-center" style="max-width: 100%">
  <img src="{{ site.url }}{{ site.baseurl }}/images/control/lane.png" alt="">
</figure>

Para rellenar los huecos, intentamos simular la superficie de la carretera. Creamos una variable que alamcena los límites de la fila anterior del carril, estableciendo inicialmente ambos límites en el centro del eje x. En cada actualización, si los límites no están definidos (con valor -1), los definimos como el valor de la fila anterior más un *offset*, que en este caso es 1. Además, verificamos que dicho valor no supere el máximo registrado con la red de detección de carril.

Estos dos procesos **solo son válidos si se confirma con la máscara de segmentación** que todo ese rango de la fila pertenece a al calzada.

La parte en rosa representa la sección definida únicamente con la red de detección de carriles, mientras que la sección en verde muestra la parte completada con la red de segmentación.
<figure class="align-center" style="max-width: 100%">
  <img src="{{ site.url }}{{ site.baseurl }}/images/control/lane_seg.png" alt="">
</figure>

## Controlador PID

Para que el vehiculo siga al carril hemosm creado finalmenet un **controlador proporcional**, ya que solo con elloobstenimos buenos resultados. El *steer*, giro de volante, puede recibir un valor de 0 a 1, por lo tanto, la contante proporcional normalizara el error en este rango, dividiendo entre la mitad de la imagen 512/2. 

Para controlar el acelerador, si el error es mayor que 15 pixeles disminuimos el acelerador, de lo contrario mantenemos una aceleracion estandar. Hemos establecido un contador para que al principio acelera mas, para alcanzar antes una velocidad adecuada.
