---
title: "Control: Sigue carril"
last_modified_at: 2024-05-16T13:52:00
categories:
  - Blog
tags:
  - PID
  - Redes neuronales
---

Implementaremos una solución combinando múltiples redes neuronales para detectar el carril y calcular la desviación del vehículo respecto al mismo. Esta información se enviará a un controlador PID para corregir la desviación y mantener al vehículo en adecuadamente en el centro del carril.

## Índice
1. [Detección de carril](#detección-de-carril)
  - [Red neuronal de detección de carril](#red-neuronal-de-detección-de-carril)
  - [Red neuronal de segmentación semántica](#red-neuronal-de-segmentación-semántica)
2. [Controlador PID](#controlador-pid)
3. [Profiling](#profiling)

## Detección de carril

Buscamos seleccionar un entorno con una única vía, rodeado de vegetación y con un cielo despejado, con el objetivo de minimizar la confusión entre el cielo, la carretera y los edificios.

### Red neuronal de detección de carril
...

### Red neuronal de segmentación semántica
Una vez que hemos determinado el área del carril, empleamos la red de segmentación para calcular el porcentaje de ese área que corresponde realmente a la carretera. Este cálculo nos permite discernir si hemos perdido el carril aunque continuamos detectando líneas, las cuales podrían ser, por ejemplo, de la acera. Si el porcentaje de área correspondiente al carril es inferior a un umbral (*threshold_road*) durante varias iteraciones seguidas (*mem_max*), detenemos la ejecución del programa. Esto será útil sobre todo en la próxima etapa, el seguimiento del carril mediante *deep reinforcement learning*.
```python
class Camera(Sensor):      
  def get_threshold_road(self)
  def set_threshold_road(self, per:float)
```

## Controlador PID

Para que el vehiculo siga al carril hemosm creado finalmenet un **controlador proporcional**, ya que solo con elloobstenimos buenos resultados. El *steer*, giro de volante, puede recibir un valor de 0 a 1, por lo tanto, la contante proporcional normalizara el error en este rango, dividiendo entre la mitad de la imagen *SIZE_CAMERA / 2*. 

Para controlar el acelerador, si el error es mayor que 15 pixeles disminuimos el acelerador, de lo contrario mantenemos una aceleracion estandar. Hemos establecido un contador para que al principio acelera mas, para alcanzar antes una velocidad adecuada.

## Profiling

Hemos dividido el código en secciones para evaluar las latencias y determinar dónde estamos consumiendo más tiempo en nuestro programa, con el objetivo de mejorar su eficiencia. Como se puede observar en la siguiente imagen, la mayor parte del tiempo se destina a realizar la prediccion con el modelo de segmentación. El resto de secciones presentan latencias acordes a su carga computacional, sin presenta una desventaja significativa para nuestro programa.
<figure class="align-center" style="max-width: 100%">
  <img src="{{ site.url }}{{ site.baseurl }}/images/control/profiling.png" alt="">
</figure>

Un cambio que implementamos después de este análisis fue convertir la funcionalidad que encapsula *Seg get canvas* en opcional, ya que solo es útil para la visualización, ya que únicamente modifica el color del píxel dependiendo de la clase a la que pertenezca según la red de segmentación. Con esto, logramos ganar algo de velocidad de cara al seguimiento del carril.